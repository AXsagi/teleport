---
authors: STeve Huang (xin.huang@goteleport.com)
state: draft
---

# RFD 67 - Redis database access in AWS ElastiCache and MemoryDB

## Required Approvers
* Engineering: @r0mant && @smallinsky Product: (@klizhentas || @xinding33)
* Security: @reed

## What

Support Redis database access in AWS
[ElastiCache](https://aws.amazon.com/elasticache/redis/) and
[MemoryDB](https://aws.amazon.com/memorydb/).

## Why

Redis is one of the most popular in-memory databases, and Amazon offers AWS
managed solutions like ElastiCache and MemoryDB.

As described in [Database Access
RFD](https://github.com/gravitational/teleport/blob/master/rfd/0011-database-access.md),
mutual TLS is used between database clients and proxy, and between proxy and
database service. The same applies to Redis access.

However, neither mutual TLS nor IAM authentication is supported by Redis
managed by AWS. This document mainly focuses on access from database service to
the Redis managed by AWS.

## Details

### In-transit encryption (TLS)

For security purposes, Teleport should ONLY
support databases with in-transit encryption (TLS) enabled.

[Enabling TLS on ElastiCache
Redis](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/in-transit-encryption.html#in-transit-encryption-enable)
can be a complicated process, and all client applications must be updated at
the same time. Therefore, Teleport should NOT automatically enable TLS for
existing clusters. Redis servers without TLS are NOT supported, and users are
recommended to enable TLS separately to enable Teleport database access.

### Auth

Redis can be configured with one of the following authentication methods, and
only one at a time.

#### Auth - Redis with no auth

Redis can be configured without any auth method.

"default" user is always used in this configuration, and no `auth` command is
required upon a successful connection.

#### Auth - Redis with Redis Auth

[Redis Auth](https://redis.io/commands/auth/)
uses a single token/password that must be shared for all client applications.

"default" user is always used in this configuration, and users have to manually
input `auth` command upon a successful connection. <sup>1<sup>

#### Auth - Redis with ACL

[Redis ACL](https://redis.io/docs/manual/security/acl/) (also known as RBAC for
ElastiCache Redis) is introduced in Redis 6. Both ElastiCache and MemoryDB
provide APIs to manage database users and user groups for ACL.

As with all other databases, the database users should be created by "database
admins" (by users, not Teleport) to assign desired permissions. 

To provide better security than using static passwords, users can tag
ElastiCache and MemoryDB users with label **`teleport.dev/managed: true`** for
Teleport to manage the passwords for those database users.

Database service discovers databases users by listing users in the ElastiCache
user group or MemoryDB ACL attached to the Redis database. For database users
discovered with label **`teleport.dev/managed: true`**, passwords are randomly
generated, periodically rotated, and securely stored in the secret store.

When a client tries to connect to ElastiCache and MemoryDB Redis servers, the
database service automatically logins Teleport managed database users by
sending `auth` command with the stored passwords to the Redis server. For
database users not managed by Teleport, users can manually input `auth`
command.

In HA mode, if more than one database service tries to rotate the password for
the same user at the same time, the secret store implementation guarantees only
the first succeeds. And only the successor should call AWS APIs to update the
database user's password.

### Secret store

#### Secret store - Interface

For ElastiCache/MemoryDB Redis usage, it is natural to use an AWS native
solution (aka [AWS Secrets Manager](https://aws.amazon.com/secrets-manager/)).
Though other secret stores could be supported in the future. <sup>[2]<sup>

Here is a sample interface for managing secrets using the secret store.
```
// SecretValue is the secret value.
type SecretValue struct {
    // Key is the key path of the secret.
    Key string
    // Value is the value of the secret.
    Value string
    // Version is the version of the secret value.
    Version string
    // Created is the creation time of this version. Can be used to calculate
    // if a secret value is expired.
    Created time.Time
}

// CreateRequest defines the request to create a new secret.
type CreateRequest struct {
    // Key is the key path of the secret.
    Key string
    // Value is the value of the secret to set. A random value is generated if
    // empty.
    Value string
    // RandomValueLength is the length of the random value to generate.
    RandomValueLength int
}

// PutValueRequest defines the request to create a new secret version.
type PutValueRequest struct {
    // CurrentValue is the current secret value. Key in CurrentValue is used to
    // identify the secret. Other attributes can be used for test-and-set
    // operations.
    CurrentValue *SecretValue
    // Value is the value of the secret to set. A random value is generated if
    // empty.
    Value string
    // RandomValueLength is the length of the random value to generate.
    RandomValueLength int
}

// Secrets defines an interface for managing secrets. A secret consists of a
// key path and a list of versions that hold copies of current or past secret
// values.
type Secrets interface {
    // Create creates a new secret.
    Create(req CreateRequest) (*SecretValue, error)

    // Delete deletes the secret for the provided path.
    Delete(key string) error

    // PutValue creates a new secret version for the secret. Implementations
    // must guarantee that only the first of many calls to PutValue succeeds,
    // when req.CurrentValue is the same.
    PutValue(req PutValueRequest) (*SecretValue, error)

    // GetValue returns the secret value for provided version. Besides version
    // string returned from PutValue, two specials versions "CURRENT" and
    // "PREVIOUS" can also be used to retrieve the current and previous
    // versions respectively. If the version is empty, "CURRENT" is used.
    GetValue(key string, version string) (*SecretValue, error)
}
```
It is up to the caller to call `PutValue` periodically to rotate the secret.

#### Secret store - AWS Secrets Manager

AWS Secrets Manager is used to store passwords for ElastiCache and MemoryDB
users. An optional `secret_store` block can be specified per database to
overwrite default settings.
```
db_service:
  enabled: "yes"

  databases:
  - name: "elasticache-example"
    protocol: "redis"
    uri: "master.example.xxxxxx.use1.cache.amazonaws.com"
    aws:
      region: "us-east-1"

      # Optional secret store settings.
      secret_store:
        # Secert name prefix. Defaults to "teleport/".
        key_prefix: "teleport/"

        # The ARN, key ID, or alias of the AWS KMS key that Secrets Manager
        # uses to encrypt the secret value. Defaults to `aws/secretsmanager`.
        kms_key_id: "my-kms-key"
```

The user must grant Teleport service the following IAM permissions to manage
the secrets:
```json
{
  "Version": "2012-10-17",
  "Statement": {
    "Effect": "Allow",
    "Action": [
      "secretsmanager:CreateSecret",
      "secretsmanager:GetSecretValue",
      "secretsmanager:PutSecretValue",
      "secretsmanager:DeleteSecret",
    ],
    "Resource": "arn:aws:secretsmanager:{region}:{account-id}:secret:{key-prefix}*"
  }
}
```
Here `key-prefix` can be used to prevent Teleport from accessing other secrets
in the AWS Secrets Manager. To encrypt the secret with a KMS key other than the
default `aws/secretsmanager`, `kms:GenerateDataKey` and `kms:Decrypt` to the
key are also required.

For racing `PutSecretValue` calls,
[`PutSecretValueInput.ClientRequestToken`](https://docs.aws.amazon.com/sdk-for-go/api/service/secretsmanager/#PutSecretValueInput)
can be used to "ensure idempotency" as AWS prevents different secret values of
the same `ClientRequestToken` to be written. When preparing `PutSecretValue`
call, an MD5 UUID can be generated from the version string of the CURRENT
value, and used for `ClientRequestToken`. When `PutSecretValue succeeds, the
`ClientRequestToken` becomes the version string of the latest value. This
effectively makes version strings rolling MD5 UUIDs of their previous versions,
and only the first call to create each version can succeed.

## Security

To reduce security risks by using passwords in backend services:
- Only well-known and attested secrets management tools are used to store
  secrets securely (e.g. AWS Secrets Manager).
- Generate random passwords (using maximum length available).
- Rotate passwords frequently.

Lastly, permissions to all AWS resources used by Teleport services are granted
through AWS IAM by users.

## UX

The user experience when using the `tsh` client to connect Redis in AWS is the
same as connecting to self-hosted Redis (or other databases).

Configuring database services to manage database users for ElastiCache and
MemoryDB does require some planning and effort from users. To improve
"time-to-first-value", [Database access
configurator](https://github.com/gravitational/teleport/blob/master/rfd/0046-database-access-config.md)
can be expanded to generate required IAM policies for ElastiCache, MemoryDB,
and Secrets Manager.

## Alternatives considered

1. Rotating secrets for Redis with Redis Auth
  - Teleport can potentially take control of the shared token and rotate it for
    security. However, users must update all other Redis client applications to
    use tokens generated by Teleport, which might require a complicated
    migration process. Teleport might also need to provide APIs for retrieving
    secret key paths or values. This could be a potential feature in the
    future.

2. Potential secret store implementations:
  - [Password Rotation with HashiCorp
    vault](https://www.hashicorp.com/resources/painless-password-rotation-hashicorp-vault).
    (Note: `put` operation supports CheckAndSet.)
